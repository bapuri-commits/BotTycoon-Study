package kr.bapuri.tycoon.antiexploit;

import kr.bapuri.tycoon.economy.EconomyService;
import kr.bapuri.tycoon.player.PlayerDataManager;
import kr.bapuri.tycoon.player.PlayerTycoonData;
import kr.bapuri.tycoon.world.WorldManager;
import kr.bapuri.tycoon.world.WorldType;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.AbstractVillager;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.ClickType;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryDragEvent;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.inventory.ItemStack;

import java.util.*;
import java.util.logging.Logger;

/**
 * VillagerTradeBlocker - 주민 거래 제한 시스템
 * 
 * 기능:
 * - 무료 거래 N회 (config)
 * - 이후 BD로 추가 거래 (tier별 점진적 비용)
 * - 월드별 적용 (config)
 * - 관리자 명령어로 조회/리셋/토글
 * 
 * 대상: AbstractVillager (일반 주민 + 떠돌이 상인)
 * 
 * 보안 강화:
 * - Shift+Click 차단 (다중 거래 익스플로잇 방지)
 * - 인벤토리 여유 공간 확인 (오버플로우 방지)
 */
public class VillagerTradeBlocker implements Listener {

    private final Logger logger;
    private final WorldManager worldManager;
    private final PlayerDataManager playerDataManager;
    private final EconomyService economyService;
    
    // ===== 설정 (antiexploit.yml에서 로드) =====
    private boolean enabled = true;
    private int freeTradeLimit = 10;
    private Set<WorldType> blockedWorlds = EnumSet.of(WorldType.WILD);
    
    // tier별 BD 비용
    private long tradeCostTier1 = 5000;   // 11~15회
    private long tradeCostTier2 = 10000;  // 16~20회
    private long tradeCostTier3 = 15000;  // 21~30회
    private long tradeCostTier4 = 25000;  // 31~50회
    private long tradeCostTier5 = 50000;  // 51회+
    
    // ===== 메시지 (일부 config에서 로드) =====
    private static final String MSG_FREE_TRADE = "§a[거래] 무료 거래 %d/%d회";
    private static final String MSG_LIMIT_REACHED = "§e[거래] 무료 거래 소진. 다음 거래: %,d BD";
    private static final String MSG_PAID_TRADE = "§a[거래] %,d BD 사용 (총 %d회, 남은 BD: %,d)";
    private static final String MSG_SHIFT_CLICK_BLOCKED = "§c[거래] Shift+Click 거래는 지원하지 않습니다. 단일 클릭으로 거래해주세요.";
    private static final String MSG_INVENTORY_FULL = "§c[거래] 인벤토리 공간이 부족합니다.";
    
    // config에서 로드하는 메시지
    private String msgInsufficientBd = "§c[거래] BD가 부족합니다. (필요: %,d, 보유: %,d)";
    
    // ===== 스팸 방지 =====
    private final Map<UUID, Long> lastMessageTime = new HashMap<>();
    private static final long MESSAGE_COOLDOWN_MS = 3000;

    /**
     * 생성자 (의존성 주입)
     */
    public VillagerTradeBlocker(WorldManager worldManager,
                                 PlayerDataManager playerDataManager, 
                                 EconomyService economyService,
                                 Logger logger) {
        this.logger = logger;
        this.worldManager = worldManager;
        this.playerDataManager = playerDataManager;
        this.economyService = economyService;
    }
    
    /**
     * 설정 로드 (antiexploit.yml)
     */
    public void loadConfig(FileConfiguration config) {
        enabled = config.getBoolean("villagerTrade.enabled", true);
        freeTradeLimit = config.getInt("villagerTrade.freeTradeLimit", 10);
        
        // tier별 BD 비용
        tradeCostTier1 = config.getLong("villagerTrade.tradeCosts.tier1", 5000);
        tradeCostTier2 = config.getLong("villagerTrade.tradeCosts.tier2", 10000);
        tradeCostTier3 = config.getLong("villagerTrade.tradeCosts.tier3", 15000);
        tradeCostTier4 = config.getLong("villagerTrade.tradeCosts.tier4", 25000);
        tradeCostTier5 = config.getLong("villagerTrade.tradeCosts.tier5", 50000);
        
        // 차단 월드 목록
        List<String> worldList = config.getStringList("villagerTrade.blockedWorlds");
        if (!worldList.isEmpty()) {
            blockedWorlds = EnumSet.noneOf(WorldType.class);
            for (String worldName : worldList) {
                try {
                    WorldType type = WorldType.valueOf(worldName.toUpperCase());
                    blockedWorlds.add(type);
                } catch (IllegalArgumentException e) {
                    logger.warning("[VillagerTradeBlocker] 알 수 없는 월드 타입: " + worldName);
                }
            }
        }
        
        // 메시지 (config에서 로드)
        String customMessage = config.getString("villagerTrade.message");
        if (customMessage != null && !customMessage.isEmpty()) {
            // 컬러 코드 변환 (&c → §c)
            msgInsufficientBd = customMessage.replace('&', '§');
        }
        
        if (enabled) {
            logger.info("[VillagerTradeBlocker] 초기화 완료 (freeLimit=" + freeTradeLimit + 
                       ", blockedWorlds=" + blockedWorlds + 
                       ", BD비용=[" + tradeCostTier1 + "/" + tradeCostTier2 + "/" + 
                       tradeCostTier3 + "/" + tradeCostTier4 + "/" + tradeCostTier5 + "])");
        } else {
            logger.info("[VillagerTradeBlocker] 비활성화됨");
        }
    }

    // ========== 이벤트 핸들러 ==========

    /**
     * 주민 우클릭 - 거래 가능 여부 확인
     */
    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onPlayerInteractEntity(PlayerInteractEntityEvent event) {
        if (!enabled) return;
        
        Entity entity = event.getRightClicked();
        if (!(entity instanceof AbstractVillager)) return;
        
        Player player = event.getPlayer();
        WorldType worldType = worldManager.getWorldType(player.getWorld());
        
        // 차단 월드가 아니면 허용
        if (worldType == null || !blockedWorlds.contains(worldType)) return;
        
        PlayerTycoonData data = playerDataManager.get(player);
        int currentTradeCount = data.getVillagerTradeCount();
        
        // 무료 거래 가능
        if (currentTradeCount < freeTradeLimit) {
            return; // 허용
        }
        
        // 무료 소진 - BD 확인
        long playerBd = economyService.getBalance(player);
        long nextCost = calculateBdCost(currentTradeCount);
        
        if (playerBd >= nextCost) {
            // BD 있음 - 허용하되 알림
            sendMessage(player, String.format(MSG_LIMIT_REACHED, nextCost));
            return;
        }
        
        // BD 부족 - 차단
        event.setCancelled(true);
        sendMessage(player, String.format(msgInsufficientBd, nextCost, playerBd));
    }

    /**
     * 상인 인벤토리 클릭 - 실제 거래 처리
     */
    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onInventoryClick(InventoryClickEvent event) {
        if (!enabled) return;
        if (!(event.getWhoClicked() instanceof Player player)) return;
        if (event.getInventory().getType() != InventoryType.MERCHANT) return;
        
        WorldType worldType = worldManager.getWorldType(player.getWorld());
        if (worldType == null || !blockedWorlds.contains(worldType)) return;
        
        // 결과 슬롯(2)만 실제 거래로 카운트
        int rawSlot = event.getRawSlot();
        if (rawSlot != 2) return;
        
        // 결과 슬롯에 아이템이 없으면 무시
        ItemStack resultItem = event.getCurrentItem();
        if (resultItem == null || resultItem.getType().isAir()) return;
        
        // [보안] Shift+Click 차단 (다중 거래 익스플로잇 방지)
        ClickType clickType = event.getClick();
        if (clickType.isShiftClick()) {
            event.setCancelled(true);
            sendMessage(player, MSG_SHIFT_CLICK_BLOCKED);
            return;
        }
        
        // [보안] 인벤토리 여유 공간 확인 (오버플로우 방지)
        if (!hasInventorySpace(player, resultItem)) {
            event.setCancelled(true);
            sendMessage(player, MSG_INVENTORY_FULL);
            return;
        }
        
        PlayerTycoonData data = playerDataManager.get(player);
        int currentTradeCount = data.getVillagerTradeCount();
        
        if (currentTradeCount < freeTradeLimit) {
            // 무료 거래
            int newCount = data.incrementVillagerTradeCount();
            sendMessage(player, String.format(MSG_FREE_TRADE, newCount, freeTradeLimit));
            return;
        }
        
        // 유료 거래 - BD 차감
        long playerBd = economyService.getBalance(player);
        long cost = calculateBdCost(currentTradeCount);
        
        if (playerBd >= cost) {
            boolean success = economyService.withdraw(player.getUniqueId(), cost, 
                    "VILLAGER_TRADE", "주민 거래 비용 (거래 #" + (currentTradeCount + 1) + ")");
            if (success) {
                int newCount = data.incrementVillagerTradeCount();
                long remaining = economyService.getBalance(player);
                sendMessage(player, String.format(MSG_PAID_TRADE, cost, newCount, remaining));
                return;
            }
        }
        
        // BD 부족 또는 차감 실패 - 차단
        event.setCancelled(true);
        sendMessage(player, String.format(msgInsufficientBd, cost, playerBd));
    }

    /**
     * 상인 인벤토리 드래그 차단
     */
    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onInventoryDrag(InventoryDragEvent event) {
        if (!enabled) return;
        if (!(event.getWhoClicked() instanceof Player player)) return;
        if (event.getInventory().getType() != InventoryType.MERCHANT) return;
        
        WorldType worldType = worldManager.getWorldType(player.getWorld());
        if (worldType == null || !blockedWorlds.contains(worldType)) return;
        
        // 상인 슬롯에 드래그 포함 시 차단
        for (int slot : event.getRawSlots()) {
            if (slot < 3) {
                event.setCancelled(true);
                return;
            }
        }
    }

    /**
     * [메모리 누수 방지] 플레이어 로그아웃 시 메시지 캐시 정리
     */
    @EventHandler
    public void onPlayerQuit(PlayerQuitEvent event) {
        lastMessageTime.remove(event.getPlayer().getUniqueId());
    }

    // ========== 헬퍼 메서드 ==========

    /**
     * 인벤토리 여유 공간 확인
     * 
     * @param player 플레이어
     * @param item 추가할 아이템
     * @return 공간이 있으면 true
     */
    private boolean hasInventorySpace(Player player, ItemStack item) {
        // 빈 슬롯이 있으면 OK
        if (player.getInventory().firstEmpty() != -1) {
            return true;
        }
        
        // 같은 아이템이 스택 가능한지 확인
        int remaining = item.getAmount();
        int maxStack = item.getMaxStackSize();
        
        for (ItemStack slot : player.getInventory().getStorageContents()) {
            if (slot != null && slot.isSimilar(item)) {
                int canAdd = maxStack - slot.getAmount();
                remaining -= canAdd;
                if (remaining <= 0) {
                    return true;
                }
            }
        }
        
        return false;
    }

    /**
     * tier별 BD 비용 계산
     */
    private long calculateBdCost(int tradeCount) {
        if (tradeCount < freeTradeLimit) {
            return 0;
        }
        
        int paidTradeNumber = tradeCount - freeTradeLimit + 1;
        
        if (paidTradeNumber <= 5) {         // 11~15회
            return tradeCostTier1;
        } else if (paidTradeNumber <= 10) { // 16~20회
            return tradeCostTier2;
        } else if (paidTradeNumber <= 20) { // 21~30회
            return tradeCostTier3;
        } else if (paidTradeNumber <= 40) { // 31~50회
            return tradeCostTier4;
        } else {                            // 51회+
            return tradeCostTier5;
        }
    }

    /**
     * 스팸 방지 메시지 전송
     */
    private void sendMessage(Player player, String message) {
        long now = System.currentTimeMillis();
        Long lastTime = lastMessageTime.get(player.getUniqueId());
        
        if (lastTime != null && now - lastTime < MESSAGE_COOLDOWN_MS) {
            return;
        }
        
        lastMessageTime.put(player.getUniqueId(), now);
        player.sendMessage(message);
    }

    // ========== 공개 API (명령어용) ==========

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
        logger.info("[VillagerTradeBlocker] enabled=" + enabled);
    }

    public int getFreeTradeLimit() {
        return freeTradeLimit;
    }

    public int getTradeCount(Player player) {
        return playerDataManager.get(player).getVillagerTradeCount();
    }

    public int getRemainingFreeTrades(Player player) {
        int used = getTradeCount(player);
        return Math.max(0, freeTradeLimit - used);
    }

    public long getNextTradeCost(Player player) {
        int tradeCount = getTradeCount(player);
        return calculateBdCost(tradeCount);
    }

    public void resetTradeCount(Player player) {
        playerDataManager.get(player).setVillagerTradeCount(0);
    }

    public void shutdown() {
        lastMessageTime.clear();
    }
}
