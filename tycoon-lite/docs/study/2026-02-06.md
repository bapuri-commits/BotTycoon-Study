# 학습 일지 — 2026-02-06

> **단계:** 2. 구조 감 잡기 (준비 이후 첫 단계 시작)

---

## 오늘 한 일

### 2-1. 진입점 파악
- [x] `TycoonPlugin.java` — `onEnable()` 읽기 (179줄)
- [x] `initServices()` / `initListeners()` / `initCommands()` 세 단계 확인
- [x] `initServices()` 안에서 어떤 기능들이 올라오는지 이름만 훑기

**메모:**
- **TycoonPlugin의 역할**: Paper 플러그인의 진입점 클래스. `extends JavaPlugin`
- **JavaPlugin**: 마인크래프트 JAR 안에 있는 추상 클래스. `onEnable()`, `onDisable()`은 추상 메서드 → 플러그인마다 구현해야 함
- **onEnable()** (179줄~2096줄): 서비스 초기화가 대부분. 외부 플러그인 연동 + 내부 시스템 초기화 코드들이 많아서 호출만 하고 실제 내용은 별도 메서드에 분리됨
- **onDisable()** (2097줄~2153줄): 양이 적음. 스케줄러 정지, 데이터 저장, 리소스 정리 위주
- **onEnable vs onDisable 차이**: 
  - onEnable = "만들기" (서비스 생성, 리스너/명령 등록, 스케줄러 시작) → 복잡해서 코드가 많음
  - onDisable = "정리하기" (스케줄러 정지, 데이터 저장, 리소스 해제) → 단순해서 코드가 적음


### 2-2. 아키텍처와 연결
- [x] STUDY_GUIDE — "서버 플러그인 상세 계층 구조" 읽기
- [x] Bootstrap → Core Services → Feature Systems → Integration → Mod 통신

**메모:**
- **onEnable 초기화의 큰 3축**: `initServices()` / `initListeners()` / `initCommands()`로 나눠서 관리한다.  
  - 서비스: 양이 많고 관계가 복잡해서 별도 init 메서드들(`initWorldSystem`, `initJobSystem` 등)로 또 나뉨  
  - 리스너/명령어: 상대적으로 단순해서 `ListenerRegistry`, `registerCommand` 헬퍼 수준에서 끝나는 경우가 많음
- **서비스 초기화 흐름(코드 관찰)**:  
  1. **Core Services** 생성: `AdminService`, `PlayerDataManager`, `WorldManager` → `ServiceRegistry`에 넣음 (`221~228줄`)  
  2. **Integration 객체들 생성**: `CitizensIntegration`, `WorldGuardIntegration`, `CoreProtectIntegration`, `LandsIntegration` → `services.setIntegrations(...)` (`234~245줄`)  
  3. **Economy + Vault 연동**: `EconomyService` 생성 후 `VaultIntegration` 등록 (`268~280줄`)  
  4. **Feature Systems 초기화**: `initShopSystem`, `initWorldSystem`, `initJobSystem`, `initCodexSystem` 등 각 기능 시스템 init 메서드 호출 (`282줄 이후`)
- **다이어그램 vs 실제 코드 순서 차이**:  
  - 다이어그램의 순서(Feature → Integration)는 **“어떤 레이어가 어떤 레이어를 쓸 수 있는지(의존 방향)”**를 보여주는 개념도에 가깝다.  
  - 실제 코드는 Feature가 Integration을 사용하려면 **Integration 객체가 먼저 생성되어 있어야 하므로** `initServices()`에서 Integration 블록을 Feature 시스템 초기화보다 앞에 둔다.
 - **이론적으로 Feature가 위에, 코드에서 Integration이 먼저인 이유 정리**:  
   - 이론상 Feature Systems는 “타이쿤이 제공하는 도메인 기능”, Integration은 “그 기능을 외부 플러그인으로 확장”하는 보조 레이어라서 다이어그램에서는 Feature를 위에, Integration을 아래에 그린다.  
   - 하지만 실제 초기화는 **“무엇을 먼저 만들어야 다른 것을 만들 수 있는가”**를 따르기 때문에, Feature가 Integration을 사용하려면 Integration 객체를 먼저 올려 둬야 하고, 그래서 코드에서는 Integration 생성이 Feature init보다 앞에 온다.
 - **WorldManager vs 월드 시스템 이해**:  
   - `WorldManager` = 월드 관련 공통 정보/헬퍼를 제공하는 **코어 서비스** (어떤 월드가 WILD/TOWN인지, 차원 링크, 월드 설정 적용 등).  
   - `initWorldSystem()` = WorldManager와 설정들을 이용해 **월드 리셋, 스폰, 포탈 격리, Wild 스폰 관리 등 여러 월드 관련 기능 묶음**을 한 번에 올리는 **기능 시스템 초기화 메서드**.  
   - 즉, “WorldManager = 월드 도메인의 두뇌/기반 서비스, 월드 시스템 = 그 두뇌를 써서 동작하는 여러 기능들 패키지”라는 느낌으로 이해.
 - **“나머지 서비스들 묶음”의 위치**:  
   - `initShopSystem`, `initCoreItemSystem`, `initWorldSystem`, `initJobSystem`, `initCodexSystem`, `initAchievementSystem`, `initTitleSystem`, `initTradeSystem`, `initRecoverySystem`, `initEnhanceSystem`, `initTaxSystem`, `initAutoFarmSystem` 등은 전부 **Feature Systems 레이어**에 속하는 개별 기능 블록들이다.  
   - 다이어그램의 JOB / SHOP / ENHANCE / CODEX / ACHIEVEMENT / TITLE / TRADE / TAX 박스에 각각 매핑된다고 보면 된다.
 - **Mod Communication 코드의 위치**:  
   - MOD COMMUNICATION LAYER(서버 쪽 `mod/*`, 클라 쪽 `tycoon-hud`/`tycoon-ui`)는 개념상 별도 레이어지만, 실제 초기화 코드는 각 기능 시스템 init 메서드 안에 섞여 있을 수 있다.  
   - 예: 직업/도감/업적 시스템이 클라이언트 UI로 데이터를 보내야 하면, 해당 `initXXXSystem` 안에서 ModDataService에 이벤트 브리지/콜백을 등록하는 식.  
   - 레이어 관점: Feature Systems → Mod Communication을 사용해 데이터를 보내는 방향(Feature가 Mod를 “쓴다”).

### 2-3. Use-case 한 줄기: 광물 캐기
- [ ] `MinerListener.java` — `onBlockBreak` 확인
- [ ] `MinerExpService.addMiningExp` → `addExp` 흐름 따라가기
- [ ] (선택) `MinerListener`가 어디서 생성·등록되는지 (`initMinerSystem` 검색)

**추적 요약:**
```
BlockBreakEvent
  →
  →
  →
```

**메모:**


---

## 새로 배운 것

- **JavaPlugin과 플러그인 생명주기**: 
  - `JavaPlugin`은 Paper/Bukkit API의 추상 클래스
  - 서버가 플러그인을 로드하면 `onEnable()` 호출, 종료/리로드 시 `onDisable()` 호출
  - 이 두 메서드를 구현하는 것이 플러그인의 시작점
  
- **onEnable이 많은 이유**: 
  - 초기화할 것이 많음 (설정 로드, 서비스 생성, 외부 연동, 리스너/명령 등록, 스케줄러 시작)
  - 그래서 `initServices()`, `initListeners()`, `initCommands()`로 분리하고, 각각에서 다른 클래스를 생성·등록
  
- **onDisable이 적은 이유**: 
  - 정리 작업이 단순함 (스케줄러 정지, 데이터 저장, 리소스 해제)
  - 대부분 "이미 만들어진 것들을 정리"만 하면 됨
  
- **TycoonPlugin의 역할**: 
  - 플러그인 켜짐/꺼짐 시점에 전체 기능을 올리고 내리는 부트스트랩
  - 실제 로직(경험치 계산, 상점 등)은 이 파일에 없고, 다른 클래스들을 만들고 등록만 함
  - "무엇을, 어떤 순서로 올릴지"만 담당
  
- **아키텍처 다이어그램 vs 실제 코드 순서**:  
  - 다이어그램은 “어떤 레이어가 어떤 레이어를 위해 존재하고, 어느 방향으로 의존하는지(Feature가 Integration을 사용할 수 있다)”를 보여주는 **개념적 구조**.  
  - 실제 `initServices()`의 순서는 “무엇을 먼저 만들어야 다른 것을 만들 수 있는가”를 따른 **구체적인 초기화 순서**로, Integration 객체를 먼저 만들고 그다음 Feature Systems를 초기화하는 것이 자연스럽다.
  
- **WorldManager와 월드 시스템의 차이**:  
  - WorldManager = 월드 도메인의 핵심 서비스(기반 정보/헬퍼 담당).  
  - 월드 시스템(initWorldSystem) = WorldManager를 이용해 월드 리셋, 스폰, 포탈 격리, Wild 스폰 관리 등 여러 월드 관련 기능들을 한 번에 올리는 Feature 시스템.
  
- **레이어별 initXXXSystem의 위치 감각**:  
  - `initShopSystem`, `initJobSystem`, `initCodexSystem`, `initAchievementSystem`, `initTitleSystem`, `initTradeSystem`, `initTaxSystem`, `initAutoFarmSystem` 등은 전부 Feature Systems 레이어에 속하는 “기능 묶음 초기화” 코드라는 점을 인식하게 됨.  
  - Mod Communication 관련 초기화는 각 기능 시스템 안에서 Core/Feature 서비스를 기반으로 설정될 수 있고, 개념상 Feature → ModComm 방향의 의존 관계를 갖는다.


---

## 질문 / 나중에 더 볼 것

- (없음)


---

## 내일 할 것

- 

